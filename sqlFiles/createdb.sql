-- Inputing all these scripts into the query tool will create all the tables and functions necessary
-- First, define all these types
CREATE TYPE valid_property_type AS ENUM ('apartment', 'bed and breakfast', 'unique home', 'vacation home');

CREATE TYPE address AS (
	house_number INTEGER,
	city VARCHAR(90),
	street VARCHAR(90),
	province VARCHAR(90),
	postal_code VARCHAR(6),
	country VARCHAR(90)
);

-- All Queries used to create tables
CREATE TABLE employees (
    user_id INTEGER NOT NULL,
    salary INTEGER,
    manager BOOLEAN DEFAULT false,
    branch_id INTEGER,
    employee_id SERIAL PRIMARY KEY
);


CREATE TABLE branch (
    branch_id SERIAL,
    manager_id INTEGER,
    country character varying(20) COLLATE pg_catalog."default",
    CONSTRAINT branch_pkey PRIMARY KEY (branch_id),
    CONSTRAINT branch_manager_id_fkey FOREIGN KEY (manager_id)
        REFERENCES employees (employee_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT chk_manager_id CHECK (check_manager(manager_id) = true)
);

-- Add constraint to employee table after creating branch table
ALTER TABLE employees
ADD CONSTRAINT branch_id FOREIGN KEY (branch_id) 
REFERENCES branch (branch_id) MATCH SIMPLE 
ON UPDATE NO ACTION ON DELETE NO ACTION;


CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    user_address address,
    first_name character varying(30) COLLATE pg_catalog."default",
    last_name character varying(30) COLLATE pg_catalog."default",
    email VARCHAR(90) NOT NULL,
    phone_number character(10) COLLATE pg_catalog."default",
    host boolean DEFAULT false,
    guest boolean DEFAULT false,
    middle_name character varying(50) COLLATE pg_catalog."default",
    password character varying(30) COLLATE pg_catalog."default" NOT NULL,
    branch_id INTEGER,
    CONSTRAINT unq_email UNIQUE (email),
    CONSTRAINT chk_email CHECK (email::text ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'::text),
    CONSTRAINT chk_phone CHECK (phone_number !~~ '%[^0-9]%'::text)
)

CREATE TABLE pricing (
    price_id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    rate_per_day numeric(12,2),
    rate_per_week numeric(12,2),
    CONSTRAINT pricing_pkey PRIMARY KEY (price_id)
);

CREATE TABLE properties (
    property_id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    pricing_id INTEGER NOT NULL,
    property_type valid_property_type NOT NULL,
    accommodates INTEGER,
    amenities character varying(800) COLLATE pg_catalog."default",
    bathrooms INTEGER,
    bedrooms INTEGER,
    property_address address,
    host_id INTEGER NOT NULL,
    CONSTRAINT properties_pkey PRIMARY KEY (property_id),
    CONSTRAINT fk_host_id FOREIGN KEY (host_id)
        REFERENCES users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT properties_pricing_id_fkey FOREIGN KEY (pricing_id)
        REFERENCES pricing (price_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
);

-- FUNCTION guest_check needs to be created before the TABLE rental_agreement is created
CREATE OR REPLACE FUNCTION check_guest(
	guest_id INTEGER)
    RETURNS boolean
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
AS $BODY$
 DECLARE result BOOLEAN;
BEGIN
 SELECT guest into result FROM users WHERE user_id = guest_id;
return result;
END
$BODY$;

CREATE TABLE rental_agreement
(
    rental_id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    property_id INTEGER NOT NULL,
    guest_id INTEGER NOT NULL,
    signing_date timestamp without time zone DEFAULT now(),
    start_date date NOT NULL,
    end_date date NOT NULL,
    price_of_stay numeric(12,2),
    payment_id INTEGER,
    CONSTRAINT rental_agreement_pkey PRIMARY KEY (rental_id),
    CONSTRAINT guest_key FOREIGN KEY (guest_id)
        REFERENCES users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT rental_agreement_payment_id_fkey FOREIGN KEY (payment_id)
        REFERENCES payments (payment_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT rental_agreement_property_id_fkey FOREIGN KEY (property_id)
        REFERENCES properties (property_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT chk_guest CHECK (check_guest(guest_id) = true)
)


CREATE TABLE reviews(
    review_id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    rental_id INTEGER NOT NULL,
    rating INTEGER,
    review_comments character varying(800) COLLATE pg_catalog."default",
    cleanliness character varying(200) COLLATE pg_catalog."default",
    rent_value INTEGER,
    CONSTRAINT review_pkey PRIMARY KEY (review_id),
    CONSTRAINT review_rental_id_fkey FOREIGN KEY (rental_id)
        REFERENCES rental_agreement (rental_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT valid_review CHECK (rating <= 10 AND rating > 0)
);

CREATE TABLE payments
(
    payment_id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    payment_method valid_payment_type NOT NULL,
    payment_status valid_payment_status NOT NULL,
    CONSTRAINT payment_pkey PRIMARY KEY (payment_id)
)


-- Functions

CREATE OR REPLACE FUNCTION check_manager(
	manager_id_x INTEGER)
    RETURNS boolean
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    
AS $BODY$
 DECLARE result BOOLEAN;
BEGIN
 SELECT manager into result FROM employees WHERE manager_id_x = employee_id;
return result;
END
$BODY$;

CREATE OR REPLACE FUNCTION calculate_price(
	property_id_x INTEGER,
	start_date date,
	end_date date)
    RETURNS numeric
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
AS $BODY$
DECLARE price NUMERIC(12,2);
DECLARE id_of_price int; DECLARE day_price NUMERIC(12,2); DECLARE week_price NUMERIC(12,2);
DECLARE rental_time int; DECLARE weeks int; DECLARE days int;
BEGIN 
SELECT pricing_id into id_of_price FROM properties WHERE property_id = property_id_x;
SELECT rate_per_day into day_price FROM pricing WHERE price_id = id_of_price;
SELECT rate_per_week into week_price FROM pricing WHERE price_id = id_of_price;
SELECT (end_date - start_date) INTO rental_time;
SELECT FLOOR(rental_time / 7) INTO weeks;
SELECT rental_time % 7 INTO days;
price = (weeks*week_price) + (days*day_price);
return price;
END
$BODY$;



CREATE FUNCTION price_trigger()
RETURNS trigger AS '
BEGIN
  IF NEW.price_of_stay IS NULL THEN
    NEW.price_of_stay := calculate_price(NEW.property_id, NEW.start_date, NEW.end_date);
  END IF;
  RETURN NEW;
END' LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION check_manager(
	manager_id_x INTEGER)
    RETURNS boolean
    LANGUAGE 'plpgsql'

    COST 100
    VOLATILE 
    
AS $BODY$
 DECLARE result BOOLEAN;
BEGIN
 SELECT manager into result FROM employees WHERE manager_id_x = employee_id;
return result;
END
$BODY$;

--- Triggers

CREATE TRIGGER price_trigger
BEFORE INSERT ON rental_agreement
FOR EACH ROW
EXECUTE PROCEDURE price_trigger();

CREATE TRIGGER user_branch_trigger
    BEFORE INSERT
    ON users
    FOR EACH ROW
    EXECUTE PROCEDURE user_branch_trigger();
GRANT ALL ON TABLE branch, employees, payments, pricing, properties, rental_agreement, reviews, users TO pmitc065;